#define CLIENT_STATE_RESTORER__PHYSICS
#define CLIENT_STATE_RESTORER__PHYSICS_2D

using Fusion;
using System;
using System.Collections.Generic;
using UnityEngine;
using static Fusion.NetworkRigidbodyBase;

namespace PhotonFusionUtil
{
    public class ClientStateRestorer
    {
        private bool _restoreSpawnsOnAfterSnapshot, _storePredictions;

        public ClientStateRestorer(bool restoreOnAfterSnapshot = true, bool storePredictions = false)
        {
            _restoreSpawnsOnAfterSnapshot = restoreOnAfterSnapshot;
            _storePredictions = storePredictions;
        }

        private int _tick;

        private Dictionary<NetworkId, NetworkPrefabId> _prefabDict;
        private Dictionary<NetworkBehaviourId, (Vector3 pos, Rotation rot)> _transformDict;
        private Dictionary<NetworkBehaviourId, (
            Vector3 velocity, Vector3 angularVelocity,
            float mass, float drag, float aDrag,
            NetworkRigidbodyFlags flags, int constraints)> _rbDict;

        private Dictionary<object, Lazy<object>> _storeEventDict = new();
        public Dictionary<object, object> _storeDict = new();

        private Dictionary<NetworkId, NetworkId> _updatedNetworkIdDict;


        public void Add(object uniqueId, Lazy<object> store)
        {
            _storeEventDict.Add(uniqueId, store);
        }

        public void TryRestore<T>(object uniqueId, Action<T> restore)
        {
            if (_storeDict.TryGetValue(uniqueId, out var data)) restore?.Invoke((T)data);
        }

        public void CheckUpdateNetworkId(NetworkId networkId, Action<NetworkId> updated)
        {
            if (_updatedNetworkIdDict.TryGetValue(networkId, out var newId)) updated?.Invoke(newId);
        }

        /// <summary>
        /// Run just before Shutdown() the old Runner.
        /// Stores information about NetworkObjects generated by Spawn().
        /// Store Position, Rotation, Velocity, AngularVelocity by default.
        /// </summary>
        public void Store(NetworkRunner runner, Func<NetworkObject, bool> storeConditions = null)
        {
            storeConditions ??= (no) => true;
            _tick = runner.Tick;
            var netBehaviours = runner.GetAllBehaviours<NetworkBehaviour>();

            var capacity = netBehaviours.Count / 2;
            _prefabDict = new(capacity);
            _transformDict = new(capacity);
            _rbDict = new(capacity);

            foreach (var NB in netBehaviours)
            {
                if (_prefabDict.TryGetValue(NB.Object.Id, out _)) continue;
                if (storeConditions.Invoke(NB.Object) && runner.Config.PrefabTable.TryGetId(NB.Object.NetworkGuid, out var prefabId))
                {
                    _prefabDict.Add(NB.Object.Id, prefabId);

                    foreach (var nb in NB.Object.NetworkedBehaviours)
                    {
#if CLIENT_STATE_RESTORER__PHYSICS
                        if (nb.TryChangeType<NetworkRigidbody>(out var rb))
                        {
                            if (_storePredictions)
                            {
                                var netFlags = rb.Rigidbody.isKinematic ? 0x1 : 0;
                                netFlags |= rb.Rigidbody.useGravity ? 0x2 : 0;
                                netFlags |= rb.Rigidbody.IsSleeping() ? 0x4 : 0;

                                _rbDict.Add(rb.Id, (rb.Rigidbody.velocity, rb.Rigidbody.angularVelocity,
                                    rb.Rigidbody.mass, rb.Rigidbody.drag, rb.Rigidbody.angularDrag,
                                    (NetworkRigidbodyFlags)netFlags, (int)rb.Rigidbody.constraints));

                                _transformDict.Add(rb.Id, (rb.Transform.position, rb.Transform.rotation));
                                continue;
                            }

                            rb.ReadNetworkRigidbodyFlags(out var flags, out var constraints);
                            _rbDict.Add(rb.Id, (rb.ReadVelocity(), rb.ReadAngularVelocity(),
                                rb.ReadMass(), rb.ReadDrag(), rb.ReadAngularDrag(), flags, (int)constraints));

                            _transformDict.Add(rb.Id, (rb.ReadPosition(), rb.ReadRotation()));
                            continue;
                        }
#endif
#if CLIENT_STATE_RESTORER__PHYSICS_2D
                        if (nb.TryChangeType<NetworkRigidbody2D>(out var rb2d))
                        {
                            if (_storePredictions)
                            {
                                var netFlags = rb2d.Rigidbody.isKinematic ? 0x1 : 0;
                                netFlags |= rb2d.Rigidbody.IsSleeping() ? 0x4 : 0;

                                _rbDict.Add(rb2d.Id, (rb2d.Rigidbody.velocity, Vector3.forward * rb2d.Rigidbody.angularVelocity,
                                    rb2d.Rigidbody.mass, rb2d.Rigidbody.drag, rb2d.Rigidbody.angularDrag,
                                    (NetworkRigidbodyFlags)netFlags, (int)rb2d.Rigidbody.constraints));

                                _transformDict.Add(rb2d.Id, (rb2d.Transform.position, rb2d.Transform.rotation));
                                continue;
                            }

                            rb2d.ReadNetworkRigidbodyFlags(out var flags, out var constraints);
                            _rbDict.Add(rb2d.Id, (rb2d.ReadVelocity(), Vector3.forward * rb2d.ReadAngularVelocity(),
                                rb2d.ReadMass(), rb2d.ReadDrag(), rb2d.ReadAngularDrag(), flags, (int)constraints));

                            _transformDict.Add(rb2d.Id, (rb.ReadPosition(), rb.ReadRotation()));
                            continue;
                        }
#endif
                        if (nb.TryChangeType<NetworkPositionRotation>(out var posRot))
                        {
                            if (_storePredictions)
                            {
                                _transformDict.Add(posRot.Id, (posRot.Transform.position, posRot.Transform.rotation));
                                continue;
                            }
                            _transformDict.Add(posRot.Id, (posRot.ReadPosition(), posRot.ReadRotation()));
                            continue;
                        }
                        if (nb.TryChangeType<NetworkPosition>(out var pos))
                        {
                            if (_storePredictions)
                            {
                                _transformDict.Add(pos.Id, (pos.Transform.position, Quaternion.identity));
                                continue;
                            }
                            _transformDict.Add(pos.Id, (pos.ReadPosition(), Quaternion.identity));
                            continue;
                        }
                    }
                }
            }

            _storeDict = new(_storeEventDict.Count);
            foreach (var pair in _storeEventDict) _storeDict.Add(pair.Key, pair.Value.Value);
            _storeEventDict = null;
        }

        /// <summary>
        /// Respawn the NetworkObjects based on the stored state.
        /// Can be executed only once per storing.
        /// </summary>
        public void SpawnsAndRestores(NetworkRunner runner,
            Func<IEnumerable<NetworkObject>, IEnumerable<NetworkObject>> spawnOrder = null,
            Action<NetworkRunner, NetworkObject> onBeforeSpawned = null,
            Action<NetworkRunner, NetworkObject> onAfterSpawned = null)
        {
            spawnOrder ??= list => list;

            // Advance ResumeSnapshot's Tick to old Runner's Tick
            while (runner.Tick != _tick) runner.Simulation.Update(runner.DeltaTime);

            foreach (var no in spawnOrder.Invoke(runner.GetResumeSnapshotNetworkObjects()))
            {
                if (!_prefabDict.TryGetValue(no.Id, out _)) continue;
                if (_restoreSpawnsOnAfterSnapshot) _prefabDict.Remove(no.Id);

                var networkObject = runner.Spawn(no,
                    onBeforeSpawned: (runner, newNO) =>
                    {
                        newNO.CopyStateFrom(no);
                        OnBeforeSpawnedBase(newNO.Id, newNO);
                        onBeforeSpawned?.Invoke(runner, newNO);
                    });
                onAfterSpawned?.Invoke(runner, networkObject);
            }

            if (!_restoreSpawnsOnAfterSnapshot) return;

            _updatedNetworkIdDict = new(_prefabDict.Count);

            // Spawns objects created after the PushHostMigrationSnapshot(). Note that the NetworkId will change
            foreach (var pair in _prefabDict)
            {
                var oldNetId = pair.Key;
                var prefabId = pair.Value;

                var networkObject = runner.Spawn(prefabId,
                    onBeforeSpawned: (runner, NO) =>
                    {
                        OnBeforeSpawnedBase(oldNetId, NO);
                        _updatedNetworkIdDict.Add(oldNetId, NO.Id);

                        onBeforeSpawned?.Invoke(runner, NO);
                    });
                onAfterSpawned?.Invoke(runner, networkObject);
            }
        }

        private void OnBeforeSpawnedBase(NetworkId netId, NetworkObject no)
        {
            foreach (var nb in no.NetworkedBehaviours)
            {
#if CLIENT_STATE_RESTORER__PHYSICS
                if (nb.TryChangeType<NetworkRigidbody>(out var rb))
                {
                    rb.WriteVelocity(_rbDict[rb.Id].velocity);
                    rb.WriteAngularVelocity(_rbDict[rb.Id].angularVelocity);
                    rb.WriteNetworkRigidbodyFlags(_rbDict[rb.Id].flags, (RigidbodyConstraints)_rbDict[rb.Id].constraints);
                    rb.WriteMass(_rbDict[rb.Id].mass);
                    rb.WriteDrag(_rbDict[rb.Id].drag);
                    rb.WriteAngularDrag(_rbDict[rb.Id].aDrag);

                    rb.WritePosition(_transformDict[rb.Id].pos);
                    rb.WriteRotation(_transformDict[rb.Id].rot);
                    continue;
                }
#endif
#if CLIENT_STATE_RESTORER__PHYSICS_2D
                if (nb.TryChangeType<NetworkRigidbody2D>(out var rb2d))
                {
                    rb2d.WriteVelocity(_rbDict[rb2d.Id].velocity);
                    rb2d.WriteAngularVelocity(_rbDict[rb2d.Id].angularVelocity.z);
                    rb2d.WriteNetworkRigidbodyFlags(_rbDict[rb2d.Id].flags, (RigidbodyConstraints2D)_rbDict[rb2d.Id].constraints);
                    rb2d.WriteMass(_rbDict[rb2d.Id].mass);
                    rb2d.WriteDrag(_rbDict[rb2d.Id].drag);
                    rb2d.WriteAngularDrag(_rbDict[rb2d.Id].aDrag);

                    rb2d.WritePosition(_transformDict[rb2d.Id].pos);
                    rb2d.WriteRotation(_transformDict[rb2d.Id].rot);
                    continue;
                }
#endif
                if (nb.TryChangeType<NetworkPositionRotation>(out var posRot))
                {
                    posRot.WritePosition(_transformDict[posRot.Id].pos);
                    posRot.WriteRotation(_transformDict[posRot.Id].rot);
                    continue;
                }

                if (nb.TryChangeType<NetworkPosition>(out var pos))
                {
                    pos.WritePosition(_transformDict[pos.Id].pos);
                    continue;
                }
            }
        }
    }

    public static class ClientStatesRestorerUtil
    {
        private static Dictionary<NetworkRunner, NetworkRunner> oldRunnerDict = new();
        private static Dictionary<NetworkRunner, ClientStateRestorer> restorerDict = new();

        public static bool TryChangeType<T>(this Component component, out T type) where T : Component
        {
            type = null;
            if (component.GetType() != typeof(T)) return false;
            type = component as T;
            return true;
        }

        private static ClientStateRestorer Restorer(this NetworkRunner runner)
        {
            if (restorerDict.TryGetValue(runner, out var storer)) return storer;
            var newStorer = new ClientStateRestorer();
            restorerDict.Add(runner, newStorer);
            return newStorer;
        }
        private static NetworkRunner OldRunner(this NetworkRunner runner)
            => oldRunnerDict.TryGetValue(runner, out var oldRunner) ? oldRunner : null;

        /// <summary>
        /// Add at the beginning of OnHostMigration()
        /// </summary>
        public static void Store(this NetworkRunner runner, Func<NetworkObject, bool> storeConditions = null)
        {
            runner.Restorer().Store(runner, storeConditions);
        }

        /// <summary>
        /// Add it right after spawning a new Runner in OnHostMigration()
        /// </summary>
        public static void SetOldRunner(this NetworkRunner runner, NetworkRunner oldRunner) => oldRunnerDict.Add(runner, oldRunner);

        /// <summary>
        /// Add at the beginning of HostMigrationResume()
        /// </summary>
        public static void SpawnsAndRestores(this NetworkRunner runner,
            Func<IEnumerable<NetworkObject>, IEnumerable<NetworkObject>> spawnOrder = null,
            Action<NetworkRunner, NetworkObject> onBeforeSpawned = null, Action<NetworkRunner, NetworkObject> onAfterSpawned = null)
        {
            runner.OldRunner().Restorer().SpawnsAndRestores(runner, spawnOrder, onBeforeSpawned, onAfterSpawned);
        }

        /// <summary>
        /// Networked properties and local variables can be stored and restored. Use with Spawned()
        /// </summary>
        public static void StoreAndTryRestore<T>(this NetworkRunner runner, object uniqueId, Lazy<object> store, Action<T> restore)
        {
            runner.Restorer().Add(uniqueId, store);
            if (oldRunnerDict.TryGetValue(runner, out var oldRunner))
            {
                oldRunner.Restorer().TryRestore<T>(uniqueId, receiveData => restore?.Invoke(receiveData));
            }
        }

        public static bool IsRestoring(this NetworkRunner runner)
            => oldRunnerDict.TryGetValue(runner, out var oldRunner) && restorerDict.TryGetValue(oldRunner, out _);

        /// <summary>
        /// Can handle NetworkId changes. Use with Spawned()
        ///  Does not work if restoreOnAfterSnapshot is false
        /// </summary>
        public static void ReceiveUpdatedNetworkId(
            this NetworkRunner runner,
            Action<(NetworkId oldId, NetworkId newId)> updated,
            params NetworkId[] networkIds)
        {
            if (!oldRunnerDict.TryGetValue(runner, out var oldRunner)) return;
            foreach (var id in networkIds)
            {
                oldRunner.Restorer().CheckUpdateNetworkId(id, newId => updated?.Invoke((id, newId)));
            }
        }

        /// <summary>
        /// Add at the end of OnPlayerJoined()
        /// </summary>
        public static void RemoveOldRunnerAndRestorer(this NetworkRunner runner)
        {
            if (oldRunnerDict.TryGetValue(runner, out var oldRunner) && restorerDict.TryGetValue(oldRunner, out var _))
            {
                restorerDict.Remove(oldRunner);
                oldRunnerDict.Remove(runner);
            }
        }
    }
}
