#define CLIENT_STATE_STORER__PHYSICS
// #define CLIENT_STATE_STORER__PHYSICS_2D
#define CLIENT_STATE_STORER__SPAWN_AFTER_SNAPSHOT

using Fusion;
using System;
using System.Collections.Generic;
using UnityEngine;
using static Fusion.NetworkRigidbodyBase;

namespace PhotonFusionUtil
{
    public class ClientStateStorer
    {
        private int _tick;

        private Dictionary<NetworkId, NetworkPrefabId> _prefabDict;
        private Dictionary<NetworkBehaviourId, (Vector3 pos, Rotation rot)> _transformDict;
        private Dictionary<NetworkBehaviourId, (
            Vector3 velocity, Vector3 angularVelocity,
            float mass, float drag, float aDrag,
            NetworkRigidbodyFlags flags, int constraints)> _rbDict;

        private Dictionary<object, Lazy<object>> _storeEventDict = new();
        public Dictionary<object, object> _storeDict = new();

        private Dictionary<NetworkId, NetworkId> _updatedNetworkIdDict;

        public void Add(object uniqueId, Lazy<object> store)
        {
            _storeEventDict.Add(uniqueId, store);
        }

        public void TryRestore<T>(object uniqueId, Action<T> restore)
        {
            if (_storeDict.ContainsKey(uniqueId)) restore?.Invoke((T)_storeDict[uniqueId]);
        }

        public void CheckUpdateNetworkId(NetworkId networkId, Action<NetworkId> updated)
        {
            if (_updatedNetworkIdDict.ContainsKey(networkId)) updated?.Invoke(_updatedNetworkIdDict[networkId]);
        }

        /// <summary>
        /// Run just before Shutdown() the old Runner.
        /// Stores information about NetworkObjects generated by Spawn().
        /// Store Position, Rotation, Velocity, AngularVelocity by default.
        /// </summary>
        public void Store(NetworkRunner runner, Func<NetworkObject, bool> storeConditions = null)
        {
            storeConditions ??= (no) => true;
            _tick = runner.Tick;
            var netBehaviours = runner.GetAllBehaviours<NetworkBehaviour>();

            var capacity = netBehaviours.Count / 2;
            _prefabDict = new(capacity);
            _transformDict = new(capacity);
            _rbDict = new(capacity);

            foreach (var NB in netBehaviours)
            {
                if (_prefabDict.ContainsKey(NB.Object.Id)) continue;
                if (storeConditions.Invoke(NB.Object) && runner.Config.PrefabTable.TryGetId(NB.Object.NetworkGuid, out var prefabId))
                {
                    _prefabDict.Add(NB.Object.Id, prefabId);

                    foreach (var nb in NB.Object.NetworkedBehaviours)
                    {

#if CLIENT_STATE_STORER__PHYSICS
                        if (nb.TryChangeType<NetworkRigidbody>(out var rb))
                        {
                            rb.ReadNetworkRigidbodyFlags(out var flags, out var constraints);
                            _rbDict.Add(rb.Id, (rb.ReadVelocity(), rb.ReadAngularVelocity(),
                                rb.ReadMass(), rb.ReadDrag(), rb.ReadAngularDrag(), flags, (int)constraints));

                            _transformDict.Add(rb.Id, (rb.ReadPosition(), rb.ReadRotation()));
                            continue;
                        }
#endif
#if CLIENT_STATE_STORER__PHYSICS_2D
                        if (nb.TryChangeType<NetworkRigidbody2D>(out var rb2d))
                        {
                            rb2d.ReadNetworkRigidbodyFlags(out var flags, out var constraints);
                            _rbDict.Add(rb2d.Id, (rb2d.ReadVelocity(), Vector3.forward * rb2d.ReadAngularVelocity(),
                                rb2d.ReadMass(), rb2d.ReadDrag(), rb2d.ReadAngularDrag(), flags, (int)constraints));

                            _transformDict.Add(rb2d.Id, (rb.ReadPosition(), rb.ReadRotation()));
                            continue;
                        }
#endif
                        if (nb.TryChangeType<NetworkPositionRotation>(out var posRot))
                        {
                            _transformDict.Add(posRot.Id, (posRot.ReadPosition(), posRot.ReadRotation()));
                            continue;
                        }
                        if (nb.TryChangeType<NetworkPosition>(out var pos))
                        {
                            _transformDict.Add(pos.Id, (pos.ReadPosition(), Quaternion.identity));
                            continue;
                        }
                    }
                }
            }

            _storeDict = new(_storeEventDict.Count);
            foreach (var pair in _storeEventDict) _storeDict.Add(pair.Key, pair.Value.Value);
            _storeEventDict = null;
        }

        /// <summary>
        /// Respawn the NetworkObjects based on the stored state.
        /// Can be executed only once per storing.
        /// </summary>
        public void SpawnsAndRestores(NetworkRunner runner,
            Func<IEnumerable<NetworkObject>, IEnumerable<NetworkObject>> spawnOrder = null,
            Action<NetworkRunner, NetworkObject> onBeforeSpawned = null,
            Action<NetworkRunner, NetworkObject> onAfterSpawned = null)
        {
            spawnOrder ??= list => list;

            // Advance ResumeSnapshot's Tick to old Runner's Tick
            while (runner.Tick != _tick) runner.Simulation.Update(runner.DeltaTime);

            foreach (var no in spawnOrder.Invoke(runner.GetResumeSnapshotNetworkObjects()))
            {
                if (!_prefabDict.ContainsKey(no.Id)) continue;
                _prefabDict.Remove(no.Id);

                var networkObject = runner.Spawn(no,
                    onBeforeSpawned: (runner, newNO) =>
                    {
                        newNO.CopyStateFrom(no);
                        OnBeforeSpawnedBase(newNO.Id, newNO);
                        onBeforeSpawned?.Invoke(runner, newNO);
                    });
                onAfterSpawned?.Invoke(runner, networkObject);
            }

#if CLIENT_STATE_STORER__SPAWN_AFTER_SNAPSHOT
            _updatedNetworkIdDict = new(_prefabDict.Count);

            // Spawns objects created after the PushHostMigrationSnapshot(). Note that the NetworkId will change
            foreach (var pair in _prefabDict)
            {
                var oldNetId = pair.Key;
                var prefabId = pair.Value;

                var networkObject = runner.Spawn(prefabId,
                    onBeforeSpawned: (runner, NO) =>
                    {
                        OnBeforeSpawnedBase(oldNetId, NO);
                        _updatedNetworkIdDict.Add(oldNetId, NO.Id);

                        onBeforeSpawned?.Invoke(runner, NO);
                    });
                onAfterSpawned?.Invoke(runner, networkObject);
            }
#endif
        }

        private void OnBeforeSpawnedBase(NetworkId netId, NetworkObject no)
        {
            foreach (var nb in no.NetworkedBehaviours)
            {
#if CLIENT_STATE_STORER__PHYSICS
                if (nb.TryChangeType<NetworkRigidbody>(out var rb))
                {
                    rb.WriteVelocity(_rbDict[rb.Id].velocity);
                    rb.WriteAngularVelocity(_rbDict[rb.Id].angularVelocity);
                    rb.WriteNetworkRigidbodyFlags(_rbDict[rb.Id].flags, (RigidbodyConstraints)_rbDict[rb.Id].constraints);
                    rb.WriteMass(_rbDict[rb.Id].mass);
                    rb.WriteDrag(_rbDict[rb.Id].drag);
                    rb.WriteAngularDrag(_rbDict[rb.Id].aDrag);

                    rb.WritePosition(_transformDict[rb.Id].pos);
                    rb.WriteRotation(_transformDict[rb.Id].rot);
                    continue;
                }
#endif
#if CLIENT_STATE_STORER__PHYSICS_2D
                if (nb.TryChangeType<NetworkRigidbody2D>(out var rb2d))
                {
                    rb2d.WriteVelocity(_rbDict[rb2d.Id].velocity);
                    rb2d.WriteAngularVelocity(_rbDict[rb2d.Id].angularVelocity.z);
                    rb2d.WriteNetworkRigidbodyFlags(_rbDict[rb2d.Id].flags, (RigidbodyConstraints2D)_rbDict[rb2d.Id].constraints);
                    rb2d.WriteMass(_rbDict[rb2d.Id].mass);
                    rb2d.WriteDrag(_rbDict[rb2d.Id].drag);
                    rb2d.WriteAngularDrag(_rbDict[rb2d.Id].aDrag);

                    rb2d.WritePosition(_transformDict[rb2d.Id].pos);
                    rb2d.WriteRotation(_transformDict[rb2d.Id].rot);
                    continue;
                }
#endif
                if (nb.TryChangeType<NetworkPositionRotation>(out var posRot))
                {
                    posRot.WritePosition(_transformDict[posRot.Id].pos);
                    posRot.WriteRotation(_transformDict[posRot.Id].rot);
                    continue;
                }

                if (nb.TryChangeType<NetworkPosition>(out var pos))
                {
                    pos.WritePosition(_transformDict[pos.Id].pos);
                    continue;
                }
            }
        }
    }

    public static class ClientStatesStorerUtil
    {
        private static Dictionary<NetworkRunner, NetworkRunner> oldRunnerDict = new();
        private static Dictionary<NetworkRunner, ClientStateStorer> storerDict = new();

        public static bool TryChangeType<T>(this Component component, out T type) where T : Component
        {
            type = null;
            if (component.GetType() != typeof(T)) return false;
            type = component as T;
            return true;
        }

        private static ClientStateStorer Storer(this NetworkRunner runner)
        {
            if (!storerDict.ContainsKey(runner))
            {
                var storer = new ClientStateStorer();
                storerDict.Add(runner, storer);
            }
            return storerDict[runner];
        }
        private static NetworkRunner OldRunner(this NetworkRunner runner)
            => oldRunnerDict.ContainsKey(runner) ? oldRunnerDict[runner] : null;

        /// <summary>
        /// Add at the beginning of OnHostMigration()
        /// </summary>
        public static void Store(this NetworkRunner runner, Func<NetworkObject, bool> storeConditions = null)
        {
            runner.Storer().Store(runner, storeConditions);
        }

        /// <summary>
        /// Add it right after spawning a new Runner in OnHostMigration()
        /// </summary>
        public static void SetOldRunner(this NetworkRunner runner, NetworkRunner oldRunner) => oldRunnerDict.Add(runner, oldRunner);

        /// <summary>
        /// Add at the beginning of HostMigrationResume()
        /// </summary>
        public static void SpawnsAndRestores(this NetworkRunner runner,
            Func<IEnumerable<NetworkObject>, IEnumerable<NetworkObject>> spawnOrder = null,
            Action<NetworkRunner, NetworkObject> onBeforeSpawned = null, Action<NetworkRunner, NetworkObject> onAfterSpawned = null)
        {
            runner.OldRunner().Storer().SpawnsAndRestores(runner, spawnOrder, onBeforeSpawned, onAfterSpawned);
        }

        /// <summary>
        /// Networked properties and local variables can be stored and restored. Use with Spawned()
        /// </summary>
        public static void StoreAndTryRestore<T>(this NetworkRunner runner, object uniqueId, Lazy<object> store, Action<T> restore)
        {
            runner.Storer().Add(uniqueId, store);
            if (oldRunnerDict.ContainsKey(runner))
            {
                runner.OldRunner().Storer().TryRestore<T>(uniqueId, receiveData => restore?.Invoke(receiveData));
            }
        }

        public static bool IsRestoring(this NetworkRunner runner)
            => oldRunnerDict.ContainsKey(runner) && storerDict.ContainsKey(runner.OldRunner());

#if CLIENT_STATE_STORER__SPAWN_AFTER_SNAPSHOT
        /// <summary>
        /// Can handle NetworkId changes. Use with Spawned()
        /// </summary>
        public static void ReceiveUpdatedNetworkId(
            this NetworkRunner runner,
            Action<(NetworkId oldId, NetworkId newId)> updated,
            params NetworkId[] networkIds)
        {
            if (!oldRunnerDict.ContainsKey(runner)) return;
            foreach (var id in networkIds)
            {
                runner.OldRunner().Storer().CheckUpdateNetworkId(id, newId => updated?.Invoke((id, newId)));
            }
        }
#endif

        /// <summary>
        /// Add at the end of OnPlayerJoined()
        /// </summary>
        public static void RemoveOldRunnerAndStorer(this NetworkRunner runner)
        {
            if (runner.OldRunner() != null && storerDict.ContainsKey(runner.OldRunner()))
            {
                storerDict.Remove(runner.OldRunner());
                oldRunnerDict.Remove(runner);
            }
        }
    }
}
